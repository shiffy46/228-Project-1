package edu.iastate.cs228.hw03;/**   A class of bags whose entries are stored in a chain of doubly linked nodes.       @author	Sam Shifflett    */public class DoublyLinkedBag<T> implements BagInterface<T>{	private DoublyLinkedNode firstNode;       // Reference to first node	private int numberOfEntries;	public DoublyLinkedBag()	{		firstNode = new DoublyLinkedNode(null);	} // end default constructor	public boolean add(T newEntry)	{		DoublyLinkedNode addNode = new DoublyLinkedNode(newEntry);				firstNode.next = addNode;		addNode.prev = firstNode;		firstNode = addNode;		numberOfEntries++;		return true;	} // end add	public T[] toArray()	{		DoublyLinkedBag<T> tempBag = new DoublyLinkedBag<T>();		DoublyLinkedNode tempNode = firstNode;				for(int i = 0; i < numberOfEntries; i++)		{			tempBag.add(tempNode.data);			tempNode.data = tempNode.prev.data;		}				T[] returnArray = (T[])new Object[numberOfEntries];		for(int i = 0; i < numberOfEntries; i++)		{			if(tempBag.firstNode.data != null)			{				returnArray[i] = tempBag.firstNode.data;				tempBag.firstNode = tempBag.firstNode.prev;			}		}				return returnArray;	} // end toArray	public boolean isEmpty() 	{		if(numberOfEntries == 0)		{			return true;		}		else		{			return false;		}	} // end isEmpty	public int getCurrentSize() 	{		return numberOfEntries;	} // end getCurrentSize	public int getFrequencyOf(T anEntry) 	{		int count = 0;		DoublyLinkedBag<T> tempBag = new DoublyLinkedBag<T>();		DoublyLinkedNode tempNode = firstNode;				for(int i = 0; i < numberOfEntries; i++)		{			tempBag.add(tempNode.data);			tempNode = tempNode.prev;		}				for(int i = 0; i < numberOfEntries; i++)		{			if(tempBag.firstNode.data == anEntry)			{				count++;			}			tempBag.firstNode = tempBag.firstNode.prev;		}				return count;	} // end getFrequencyOf	public boolean contains(T anEntry)	{		DoublyLinkedBag<T> tempBag = new DoublyLinkedBag<T>();		DoublyLinkedNode tempNode = firstNode;				for(int i = 0; i < numberOfEntries; i++)		{			tempBag.add(tempNode.data);			tempNode = tempNode.prev;		}				while(tempBag.firstNode != null)		{			if(tempBag.firstNode.data == anEntry)			{				return true;			}			tempBag.firstNode = tempBag.firstNode.prev;		}		return false;	} // end contains	public void clear() 	{		while(numberOfEntries > 0)		{			this.remove();		}	} // end clear	public T remove()	{		DoublyLinkedNode tempNode = new DoublyLinkedNode(null);				tempNode = firstNode;		firstNode = firstNode.prev;		tempNode = null;		if(numberOfEntries != 0)		{			numberOfEntries--;		}		return firstNode.data;			} // end remove	public boolean remove(T anEntry) 	{		DoublyLinkedNode tempNode = firstNode;				while(tempNode != null)		{			if(tempNode.data == anEntry)			{				tempNode.prev.next = tempNode.next;				if(tempNode.next != null)				{					tempNode.next.prev = tempNode.prev;				}				return true;			}			tempNode = tempNode.prev;			numberOfEntries--;		}		return false;	}	public T replace(T replacement)	{		if(numberOfEntries != 0)		{			T data = (T)new Object();			data = firstNode.data;			firstNode.data = replacement;			return data;		}		else		{			return null;		}	}		public void removeEvery(T anEntry)	{		DoublyLinkedNode tempNode = new DoublyLinkedNode(null);				tempNode = firstNode;				while(tempNode != null)		{			if(tempNode.data == anEntry)			{				tempNode.data = null;			}			tempNode = tempNode.prev;		}	}		/**	 Override the equals method of Object class so that it returns true when the contents of two DoublyLinkedBags are same. Note that two equal DoublyLinkedBags contain the same number of entries, and each entry occurs in each DoublyLinkedBag the same number of times. I.e., the elements in two do not need to be in exact same location.	 	 Before checking the contents inside this method make sure that the passed in object is not null, is of the same runtime class, and the lengths are same. If any of these fail you can return false. Otherwise, you base your return results on contents. (At the start you can also do the quick check if both refer to the same object in memory.)	 	*/	@Override	public boolean equals(Object obj)	{		if(!(obj instanceof DoublyLinkedBag))		{			return false;		}				if(obj == this)		{			return true;		}				if(getClass() != obj.getClass())		{			return false;		}				DoublyLinkedBag<T> newBag = (DoublyLinkedBag<T>) obj;				if(numberOfEntries != newBag.getCurrentSize())		{			return false;		}				DoublyLinkedNode Node1 = firstNode;		DoublyLinkedNode Node2 = newBag.firstNode;				for(int i = 0; i < numberOfEntries; i++)		{			if(!Node1.data.equals(Node2.data))			{				return false;			}			Node1 = Node1.prev;			Node2 = Node2.prev;		}		return true;	}		/**	 Returns String representation of the items in this bag.	 For example, it would return [A, B, C] if bag had three Strings "A", "B", and "C".	 	 @return String representation of items in this bag enclosed in square brackets, separated by comma and a single space (see example above). You can rely on the fact that items' proper toString method was implemented. In this method ONLY if you need to you can use String class's methods. Also, ONLY in this method you can use fully qualified name for StringBuffer class, and use all of its methods.	*/	@Override	public String toString()	{		//TODO		return "[]"; // this is returned in case bag is empty.	}		// A class of nodes for a chain of doubly linked nodes.	private class DoublyLinkedNode 	{		private T	data;					// Entry in bag		private DoublyLinkedNode next;		// Link to next node		private DoublyLinkedNode prev;	// Link to previous node		private DoublyLinkedNode(T dataPortion)		{			this(dataPortion, null, null);			} // end constructor		private DoublyLinkedNode(T dataPortion, DoublyLinkedNode nextNode,				DoublyLinkedNode previousNode)		{			data = dataPortion;			next = nextNode;			prev = previousNode;		} // end constructor			} // end DoublyLinkedNode} // end DoublyLinkedBag